\chapter{Introduction}\label{chap:intro}

	\nocite{*} 
	%TODO :: add this in better position	
	
	\paragraph{}
	Conjecture is a statement that its validity is not determined yet and need to be proved. There are two types of conjectures: Valid Conjectures, and Failed ones. Valid conjectures are the conjectures that are true in every interpretation of the problem specification. On the other hand, Failed conjectures are the ones that are inconsistent in some interpretation.
	
	
	\paragraph{}
	Given a specification consisting of some axioms and possibly some conjectures. Automated theorem provers can provide a proof and sometimes a derivation in the case of valid conjectures. Automated theorem provers are able to prove those specifications by many methods. Proving by contradiction is a leading one of those methods and it used by many Calculi. Moreover, it is used by the saturation based theorem prover E. The basic idea in proving by contradiction is having the axioms in addition to the negation of the conjecture(s). Then applying to them the different rules of the implemented calculus till a contradiction is found. So when you prove that the negation of x is false, then x is true in the first place.
	
	
	\paragraph{}
	So when the Conjectures are failed ones, the contradiction does not exist. However, a state of saturation is reached where no more clauses could be generated or simplified using any rules of the calculi. The clauses at the saturation phase are in some sense a model for the specification, since all the clauses satisfies the original set. But it is notable to mention that this model is not an explicit one.  
	
	
	\paragraph{}
	Constructing Models has a huge importance in many fields specially in debugging tasks. It helps in modelling and highlighting the existence of bugs. And because of this it is used extensively in the field of Software and Hardware verification, also in analyzing and verifying Theorems.

	\paragraph{}
	So a concrete example to show its importance is the verification of Timsort algorithm, which was explained in details here \cite{TIMSORT}. Timsort is a hybrid sorting algorithm that was developed in 2002. It combines merge sort and insertion sort. And it was developed in the beginning to be used in python, but later on it was added to java. And today in Open JDK, Sun's JDK, and Android SDK it is the default sorting algorithm since it showed a great performance over real data. That resulted in using it in billions of devices because of the popularity of those platforms. In 2015, a formal verification for Timsort was tried to be done by a team using KeY, a verification tool for java programs that could be found here \url{http://www.key-project.org/}. And their analysis showed that the TimSort algorithm was broken and they found a bug and they corrected it, then after that they were able to formally verify the correction of the algorithm. And all the happened by the help of KeY. So it is really beneficial to be able to have models.

	\paragraph{}
	Having that importance in mind, we needed in this project to have an explicit model given to user when running problems on the theorem prover E, specifically for a sub-class of \ac{fol}, or a fragment, named \ac{epr}. And in order to achieve that goal, Transformations have been applied to the problem specification to transform it to a certain form, namely range restricted form. Afterwards, Bachmair and Ganzinger Model Construction Technique is applied to extract the explicit model from the saturated set of the problem specification. 


	\paragraph{}
	So a discussion of the work done will be given in the following order. We will have a background on the topic in chapter \ref{chap:background}. Then in chapter \ref{chap:meth_and_impl} we will discuss the methodology followed and the implementation. Then an overview of related work will be in chapter \ref{chap:rel_work}. Afterwards in chapter \ref{chap:test_and_val} we will explain the procedures followed to test the accuracy and efficiency of the implemented techniques. Moreover, A discussion of the results will be found in chapter \ref{chap:res_and_lit}. Then a conclusion will be given in chapter \ref{chap:concl}. And last but not least a discussion for related future work will be in chapter \ref{chap:todo}. 
